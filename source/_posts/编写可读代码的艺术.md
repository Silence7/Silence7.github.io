---
title: 编写可读代码的艺术
date: 2020-08-11 19:44:01
tags:
---

## 代码可读性的判断准则

## 表层改进

### 变量以及函数命名

### 代码注释

## 代码的流程和逻辑改进

### 流程控制变得易读

#### 1. 条件表达式参数顺序

- 左侧为经常变化的变量，右侧更倾向于常量
- 尤达表示

```c++
if NULL == ptr {
    // 常量写在变量左侧，是需要规避语法可能产生的BUG， 如：ptr = NULL, 现在的编译器检查可以友好的检查排除，这种写法比较过时
}
```

#### 2. 条件表达式的编写顺序

- 按照正逻辑优先原则

- 先处理简单的情况

- 先处理可疑的情况
  
```c++
// 采用什么样的原则更好，需要根据具体场景选择
// 有些场景下, 负逻辑比正逻辑更简洁
// 优先处理简单情况，一直是正确的选择
// 可疑的场景先处理，逻辑会更清晰，代码缺陷更少
if !bRet {
    return
}

if case1 == "simple" {
    // do something
    return
}

if param == error {
    // do something
    return
}

// dosomething

```

#### 3. if/else 三目表达式(?:) switch/case

- 简单场景下，三目表达式更紧凑，缺点是不方便调试，有些语言删掉了此特性，如golang

- 条件分支比较多的场景下，采用switch/case 语句，更复杂的场景，需要重设计上考虑采用strategy

#### 4. 循环

- 避免使用do/while 循环，把条件表达式放在前面，减少逻辑上的困惑

- 除明确需要死循环的场景，所有的循环需要明确有结束循环的机制，特别是条件参数依赖外部的场景下

```c++
// 一个反例， 执行一次还是一直执行
do {
    continue;
} while (false)

```

#### 5. 在函数中善于使用提前返回

```C++
// 常见场景，函数参数校验，不符合就提前返回
```
  
#### 6. 尽量避免使用goto

```c++
// goto 使用的唯一场景，是函数有唯一出口
// 多个出口，就会是灾难
```

#### 7. 最小化的嵌套

```C++
// 不好的嵌套调用
if Case1 == "success" {
    if Case2 == "Failed" {
        // do something
    }
} else {
// do something
}

// 采用提前返回原则，减少过多的嵌套
if Case1 != "success" {
    // do something
    return
}

if Case2 == "Failed" {
    // do something
    return
}
```
  
#### 8. 尝试读懂你的流程

```C++
// 反复读自己写的代码，是否会有流程上的困惑和歧义
```

#### 9. 变量的使用

- 减少变量使用
- 变量作用域尽可能的短
- 尝试使用const、final、常量

### 重新组织代码

- 抽取出与目的无关的子任务
- 重新组织函数，使之只做一件事情
- 使用自然语言描述代码，用这个描述来帮助找到更简洁的解决方案

#### 1. 抽离独立的子任务到独立函数

#### 2. 构建工具代码库

#### 3. 简化已有的接口

