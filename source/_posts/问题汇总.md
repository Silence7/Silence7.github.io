---
title: 问题汇总
date: 2020-10-09 15:27:02
tags:
---

## Go语言类

- 切片需要注意的地方

> 切片是引用类型，底层数据结构包含数据指针，还有长度和容量。
> 问题点一：多个切片指向同一个切片引用时，修改谋个切片会导致所有切片被覆盖修改。解决方案：复制新切片通过copy函数

```go
var a = make([]int, 0, 10)
// b = append(a, 1)
var b []int
copy(a, b)
```

> 问题点二：切片的扩容，切片添加元素未触发扩容，会导致源切片值被覆盖修改。解决方案：新引用切片，需要指定长度=容量，再追加新内容时，触发扩容机制

```go
var a = []int{1,2,3,4,5}
// b = a[0:2]
b = a[0:2:2]
b = append(b, 0)
```

- defer 函数陷阱

> defer延迟函数，defer后的函数语句延迟到当前函数返回时执行，多个defer语句的执行顺序是按照申明的逆序，类似栈的顺序。
> defer函数的执行过程

```shell
# defer机制分为deferproc和deferreturn
# deferproc是在函数执行流中调用，执行流程如下
# 申请defer对象结构体，把结构体挂载到当前goruntime的G对象defer链上
# 保存defer调用的函数地址和参数到defer结构体中
# 返回到调用deferproc的地方，执行后面的语句

# deferreturn是在函数return处理中调用，执行流程如下：
# 在当前goruntime的G对象defer链上找需要处理的defer函数，没有就返回
# 把defer对象中的defer执行函数和参数拷贝到当前栈上
# 释放defer对象
# 通过jmpdefer命令执行defer函数

```

> defer与return的执行顺序

```shell
# return开始，执行函数或者表达式
# 执行deferreturn
# 执行return，当前函数栈返回值整理
```

> 陷阱一：defer 函数传递参数

``` go
func g(i int) {
    fmt.PrintLn(i) // 打印1
}

func c(i int) {
    i = 1
    defer g(i)

    i = 2
    return i // 返回2
}
```

> 陷阱二：defer 函数修改全局变量

```go
var i= 10

func g() {
    i = 100
}

func c() int {
    defer g(i)

    fmt.PrintLn(i)

    return i // 返回10，全局变量不在栈空间，return表达式先于defer执行
}

func main() {
    j = c()
    fmt.PrintLn(j) // 打印10
    fmt.PrintLn(i) // 打印100
}
```

> 陷阱三：defer 函数修改局部变量

```go

func c(i int) int {
    i = 10
    defer func() {
        i = 100
    }()

    fmt.PrintLn(i) // 打印10

    return i // 返回100，return赋值10，defer会修改栈上数据为100
}

func main() {
    j = c()
    fmt.PrintLn(j) // 打印10
    fmt.PrintLn(i) // 打印100
}
```
