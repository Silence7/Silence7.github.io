---
title: 问题汇总
date: 2020-10-09 15:27:02
tags:
---

## Go语言类

### 切片需要注意的地方

> 切片是引用类型，底层数据结构包含数据指针，还有长度和容量。
-  问题点一：多个切片指向同一个切片引用时，修改谋个切片会导致所有切片被覆盖修改。解决方案：复制新切片通过copy函数

    ```go
    var a = make([]int, 0, 10)
    // b = append(a, 1)
    var b []int
    copy(a, b)
    ```

- 问题点二：切片的扩容，切片添加元素未触发扩容，会导致源切片值被覆盖修改。解决方案：新引用切片，需要指定长度=容量，再追加新内容时，触发扩容机制

    ```go
    var a = []int{1,2,3,4,5}
    // b = a[0:2]
    b = a[0:2:2]
    b = append(b, 0)
    ```

### defer 函数陷阱

- 陷阱一：defer 函数传递参数

    ``` go
    func g(i int) {
        fmt.PrintLn(i) // 打印1
    }

    func c(i int) {
        i = 1
        defer g(i)

        i = 2
        return i // 返回2
    }
    ```

- 陷阱二：defer 函数修改全局变量

    ```go
    var i= 10

    func g() {
        i = 100
    }

    func c() int {
        defer g(i)

        fmt.PrintLn(i)

        return i // 返回10，全局变量不在栈空间，return表达式先于defer执行
    }

    func main() {
        j = c()
        fmt.PrintLn(j) // 打印10
        fmt.PrintLn(i) // 打印100
    }
    ```

- 陷阱三：defer 函数修改局部变量

    ```go

    func c(i int) int {
        i = 10
        defer func() {
            i = 100
        }()

        fmt.PrintLn(i) // 打印10

        return i // 返回100，return赋值10，defer会修改栈上数据为100
    }

    func main() {
        j = c()
        fmt.PrintLn(j) // 打印10
        fmt.PrintLn(i) // 打印100
    }
    ```

### Go语言引用类型，哪些可以和nil比较

> 引用类型：slice，map，channel, pointer

### GO的死锁的产生，如何避免

> 这里考察的其实是channel的使用
> 在Go语言里，并发依赖便利的goroutine，而goroutine之间的通信，是通过channel完成
> 对channel是使用不当，会导致goruntine的死锁

- 阻塞的channel， 导致死锁

```go
// 阻塞channel的使用导致死锁
package main

import "fmt"

func main() {
    var ch  = make(chan int)  //换成非阻塞的channel var ch  = make(chan int， 1)
    i := <-ch       // 阻塞channel导致死锁
    fmt.Println(i)
    ch <- 1
}
```

```go
package main

import "fmt"

func main() {
    var ch  = make(chan int)
    go func(c chan int) {
        fmt.Println(<- c)
        fmt.Println(<- c) // 这里多读会阻塞
    }(ch)

    ch <- 1
    // close(ch) // 不写数据以后，可以关闭
}
```

- 互相等依赖的channel读取，会导致死锁

```go
package main

import "fmt"

func main() {
    var c1  = make(chan int)     // 申明为非阻塞， 可以解开死锁
    var c2  = make(chan int)     // 申明为非阻塞， 可以解开死锁
    go func(r chan int, s chan int) {
        s <- 1             // 等main协程收数据，阻塞
        fmt.Println(<- r)
        // s <- 1          // 写调整到读取以后，解开死锁
    }(c1, c2)

    c1 <- 1                // 等go协程读数据，阻塞
    fmt.Println(<- c2)
}
```

- 未初始化的channel，读写导致死锁

```go
package main

import (
    "fmt"
)

type User struct {
    Name string
}

func main() {
    var ch chan int
    i := <- ch         // 读和写都会永远阻塞，导致死锁

    fmt.Println(i)

}
```

- select 未命中导致死锁

```go
package main

import "time"

func main() {
    var ch  = make(chan int)  // 如果修改为非阻塞channel， go里会阻塞，程序不会报错，但是goroutine已经泄露
    go func(c chan int) {
        select {
        case c <- 1:
        // default:       // select 未命中读case，也没有default 分支，会阻塞
        }
    }(ch)

    ch <- 1
}
```

- sync.WaitGroup 导致死锁

```go
package main

import (
    "sync"
)

func main() {
    var wg sync.WaitGroup
    var ch = make(chan int, 15)

    for i := 0; i < 10; i++ { // wg 添加10个
        wg.Add(1)
        go func() {
            ch <- 1
        }()
    }

    for i := 0; i < 5; i++ { // wg 减少5个
        go func() {
        wg.Done()
            <- ch
        }()
    }

    wg.Wait()   // 永远阻塞，程序报错
}
```

- 总结

> 使用channel时尽量使用非阻塞的chan，select 需要实现default分支，或者设置超时检测的分支
> 在goroutine之间同步，尽量使用context的超时机制，sync.WaitGroup不够灵活

### channel通信需要注意的问题

- 尽量避免channel传递指针或者引用

> channel传递数据，是以拷贝的方式，如果传递指针或者引用，在多个协程内会被修改掉。
> channel如果传递值，多个协程中的数据以副本的形式存在

```go
package main

import (
    "fmt"
    "time"
)

type User struct {
    Name string
}

func main() {
    var ch = make(chan *User)

    u := &User{
        Name: "Jerry",
    }

    go func(c chan *User) {
        d := <- c
        time.Sleep(1 * time.Second)
        fmt.Println(d.Name)         //输出是Tom
    }(ch)

    ch <- u
    u.Name = "Tom"

    time.Sleep(3 * time.Second)
}
```


