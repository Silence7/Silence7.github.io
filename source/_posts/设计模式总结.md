---
title: 设计模式总结
date: 2019-12-01 11:16:38
tags:
---

## 设计模式

> 学习地址： https://refactoringguru.cn/design-patterns/catalog

### 单例模式

### 工厂模式

### 抽象工厂

### 策略模式

#### 设计原理

> 需要实现一组算法，而不同的算法可以互相替代

- 提供一类算法接口定义，所有的算法都需要实现这类接口

- 策略可以通过配置初始化，通过工厂生成，或者查表法得到具体的算法策略

- 策略与策略之间没有相互依赖，完全解耦

#### 应用场景

- 设计一个路由限流功能，限流的算法有多种实现，随机，轮询，加权轮询等

#### 代码示例

```go
type ILimitStratege interface {
    Limit()
}

type RandomStratege struct {

}

func (ptr *RandomStratege) Limit() {
    fmt.Println("RandomStratege")
}

type PollStratege struct {

}

func (ptr *PollStratege) Limit() {
    fmt.Println("PollStratege")
}

var StrategeMap = map[string]ILimitStratege{
    "random": RandomStratege{},
    "poll": PollStratege{},
}

func GetStratege(s string) ILimitStratege {
    stratege, ok := StrategeMap[s]
    if !ok {
        return nil
    }

    return stratege
}

func main() {
    s := GetStratege("random")
    s.Limit()
}
```

### 责任链模式

#### 设计原理

> 把请求的发送和接受解藕，多个接收对象，按照条件处理请求对象，可以是顺序处理，可以未知处理

- 处理逻辑接口，包含处理handle接口, 请求上下文需要通过参数方式传入
- 实现链对象, 需要实现下一链的的接口
- 逻辑接口实现对象

#### 应用场景

- web框架过滤器，拦截器

#### 代码示例

```go
// 简单的过滤器实现

// 处理逻辑接口
type IFilter interface {
    Filter(string) bool
}

type FilterChain struct {
    Chain []Filter // 简单的数组存储
    Index int
}

func (ptr *FilterChain) AddChain(f IFilter) {
    ptr.Chain = append(ptr.Chain, f)
}

// 顺序执行
func (ptr *FilterChain) Filter(req string) bool {
    for _, chain := range ptr.Chain {
        if nil != chain {
            if !chain.Filter(req) {
                return false
            }
        }
    }

    return true
}

// 变种实现
func (ptr *FilterChain) Next(req string) {
    ptr.index++
    for ptr.index < len(ptr.Chain) {
        ptr.Chain[ptr.index](req)
        ptr.index++
    }
}

type LowFilter struct {

}

func (ptr *LowFilter) Filter(req string) bool {
    fmt.Println("LowFilter")
    return true
}

type HighFilter struct {

}

func (ptr *HighFilter) Filter(req string) bool {
    fmt.Println("HighFilter")
    return true
}

func main() {
    chain := FilterChain{}
    chain.AddChain(&LowFilter{})
    chain.AddChain(&HighFilter{})
    chain.Handle("req")
}
```

### 状态模式

#### 设计原理

> 状态模式是一种行为模式，对象根据不同的状态执行不同的行为动作，并会产生状态变化。策略模式下，行为对状态改变是未知的

- 状态数据上下文对象, 包含行为接口对象，状态上下文数据
- 行为接口
- 状态行为实现对象，行为逻辑实现以及状态流转

#### 应用场景

> 简单的状态行为选择 if、switch；有限的状态，而且当行为逻辑比较复杂采用状态模式；状态比较多，状态转换复杂，采用查表法

- 插入说明链接

####  代码示例

```go
// 示例场景，工作审批流程
// 提交审批流程->领导审批->人事审批->结束

// 行为接口
type IState interface {
    Approval(*WorkFlow)
    Reject(*WorkFlow)
    GetState() string
}

// 状态上下文对象
type WorkFlow struct {
    State IState
}

func (ptr *WorkFlow) SetState(state IState) {
    ptr.State = state
}

func (ptr *WorkFlow) Approval() {
    if nil != ptr.State {
        ptr.State.Approval()
    }
}

func (ptr *WorkFlow) Reject() {
    if nil != ptr.State {
        ptr.State.Reject()
    }
}

func (ptr *WorkFlow) GetState() {
    if nil != ptr.State {
        ptr.State.GetState()
    }
}

// 状态行为实现
type LeaderState struct {
    StateName string
}

func (ptr *LeaderState) Approval(w *WorkFlow) {
    fmt.Println("Leader Approval")
    w.SetState(&HRState{})
}

func (ptr *LeaderState) Reject(w *WorkFlow) {
    fmt.Println("Leader Reject")
}

func (ptr *LeaderState) GetState() string {
    return ptr.StateName
}

type HRState struct {
    StateName string
}

func (ptr *HRState) Approval(w *WorkFlow) {
    fmt.Println("HR Approval")
}

func (ptr *HRState) Reject(w *WorkFlow) {
    fmt.Println("HR Reject")
    w.SetState(&HRState{})
}

func (ptr *HRState) GetState() string {
    return ptr.StateName
}

func main() {
    w := WorkFlow{}
    //start
    w.SetState(&LeaderState{StateName: "LeaderState"})
    // LeaderState
    w.Approval()

    // Approval
    w.GetState()
    // HRReject
    w.Reject()

    // LeaderState
    w.GetState()

    // LeaderApproval
    w.Approval()

    // HRApproval
    w.GetState()

    // HRApproval
    w.Approval()
    w.GetState()
    // end
}

```

### 访问者模式

#### 设计原理

> 需要对一组对象进行操作访问，而又需要保证对象对封装特性。这个模式的对象关系比较复杂，尽量不做使用

- 操作对象对逻辑通过一组接口和实现类封装起来，对象的信息通过接口参数传递。

- 对象保留实现访问者的接口方法，达到操作解藕的目的

- 访问者必需知道所有的操作对象类

#### 应用场景

- 在系统中生成的单据文件，进行格式化输出

- 如报销单、请假单

- 输出格式支持pdf、doc

#### 代码示例

```go
// 访问者接口
type IVisitor interface {
    PDFVisit(IForm)   // 具体的对象操作逻辑实现接口
    DOCVisit(IForm)   // 具体的对象操作逻辑实现接口
}

// 具体操作实现类
type PDFVisitor struct {

}

func (ptr *PDFVisitor) PDFVisit(form IForm) {
    fmt.Println("PDFVisitor")
}

func (ptr *PDFVisitor) DOCVisit(form IForm) {
    fmt.Println("error visitor")
}

// 具体操作实现类
type DOCVisitor struct {

}

func (ptr *DOCVisitor) PDFVisit(form IForm) {
    fmt.Println("error visitor")
}

func (ptr *DOCVisitor) DOCVisit(form IForm) {
    fmt.Println("DOCVisitor")
}

// 单据基类
type IForm interface {
    Accept(IVisitor) // 提供访问接口，实现操作逻辑解藕
}

// 账单
type StatementForm struct {

}

func (ptr *StatementForm) Accept(visitor IVisitor) {
    visitor.PDFVisit(ptr)
}

// 假期单据
type VacationForm struct {

}

func (ptr *VacationForm) Accept(visitor IVisitor) {
    visitor.DOCVisit(ptr)
}

func main() {
    s := StatementForm{}
    v := VacationForm{}

    p := &PDFVisitor{}
    s.Accept(p)

    d:= &DOCVisitor{}
    v.Accept(d)
}

```
