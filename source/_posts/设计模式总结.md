---
title: 设计模式总结
date: 2019-12-01 11:16:38
tags:
---

## 设计模式

> 学习地址： https://refactoringguru.cn/design-patterns/catalog

> 一组对象，基类描述共性，子类描述特性；一组行为，接口定义行为，实现类定义逻辑

### 单例模式

#### 设计原理

- 只需要全局唯一的一个实例，如统一的日志管理接口
- 全局初始化一个静态实例，提供get接口返回这个实例的引用

#### 应用场景

- 常见的日志管理模块，全局唯一

#### 代码示例

```go
type Single struct {

}

var SingleLock sync.Mutex
var GlobalSingleInstance *Single

func GetInstance() *Single {
    if GlobalSingleInstance == nil {
        SingleLock.lock()             // 这里锁还可以使用sync.Once()
        defer SingleLock.Unlock()

        if GlobalSingleInstance == nil {    // 双重判断，减少锁竞争
            GlobalSingleInstance = &Single{}
        }
    }

    return GlobalSingleInstance
}
```

### 工厂模式&抽象工厂

#### 设计原理

- 工厂模式：通过静态方法实现创建不同的对象实例
- 抽象工厂：通过静态方法实现创建一组工厂实例对象

#### 应用场景

- 知道需要生成的具体对象

#### 代码示例

```go
type ICar interface {
    GetName()
}

type BMWCar struct {

}

func (ptr *BMWCar) GetName() {
    fmt.Println("BMW")
}

type BENSCar struct {

}

func (ptr *BENSCar) GetName() {
    fmt.Println("BENS")
}

type AODICar struct {

}

func (ptr *AODICar) GetName() {
    fmt.Println("AODI")
}

// 工厂模式只生成具体的实例对象
func CreateCar(car string) ICar {
    switch car {
        case "bmw":
        return &BMWCar{}
        case "bens":
        return &BENSCar{}
        case "aodi":
        return &AODICar{}
        default:
        return nil
    }
}

```

```go
// 方法接口类
type INomalCar interface {
    GetNormalName()
}

// 方法接口类
type ISuvCar interface {
    GetSuvName()
}

// 具体实现类
type BMWNormalCar struct {

}

func (ptr *BMWNormalCar) GetNormalName {
    fmt.Println("BMW Normal")
}

type BMWSuvCar struct {

}

func (ptr *BMWSuvCar) GetSuvName {
    fmt.Println("BMW Suv")
}

type BENSNormalCar struct {

}

func (ptr *BENSNormalCar) GetNormalName {
    fmt.Println("BENS Normal")
}

type BENSSuvCar struct {

}

func (ptr *BENSSuvCar) GetSuvName {
    fmt.Println("BENS Suv")
}

type AODINormalCar struct {

}

func (ptr *AODINormalCar) GetNormalName {
    fmt.Println("AODI Normal")
}

type AODISuvCar struct {

}

func (ptr *AODISuvCar) GetSuvName {
    fmt.Println("AODI Suv")
}

// 抽象工厂类
type ICar interface {
    GetNormal() INomalCar // 普通车型
    GetSuv() ISuvCar      // suv车型
}

type BMWCar struct {
}

// 具体工厂实现类
func (ptr *BMWCar) GetNormal() INomalCar {
    fmt.Println("BMW normal")
}

func (ptr *BMWCar) GetSuv() ISuvCar {
    fmt.Println("BMW suv")
}

type BENSCar struct {

}

func (ptr *BENSCar) GetNormal() INomalCar {
    fmt.Println("BENS normal")
}

func (ptr *BENSCar) GetSuv() ISuvCar {
    fmt.Println("BENS suv")
}

type AODICar struct {

}

func (ptr *AODICar) GetNormal() INomalCar {
    fmt.Println("AODI normal")
}

func (ptr *AODICar) GetSuv() ISuvCar {
    fmt.Println("AODI suv")
}

// 静态方法, 获取具体的工厂
func CreateCar(car string) ICar{
    switch car {
        case "bmw":
        return &BMWCar{}
        case "bens":
        return &BENSCar{}
        case "aodi":
        return &AODICar{}
        default:
        return nil
    }
}
```

### 原型模式

#### 设计原理

- 通过接口和方法，实现复制一个对象实例，并对对象属性无任何依赖
- 解决的是对象私有变量的访问

#### 应用场景

- 需要复制对象实例，而不允许对象属性的访问

#### 代码示例

```go

type ProtoType interface {
    GetName()
    Clone() ProtoType
}

type Machine struct {
    name string
}

func (ptr *Machine) GetName() {
    fmt.Println("Machine Name:%s", ptr.name)
}

func (ptr *Machine) Clone() ProtoType {
    return &Machine{
        name: ptr.name,
    }
}

func main() {
    m := &Machine{
        name: "m",
    }

    c := m.Clone()
    c.GetName()
}
```

### 生成器模式

#### 设计原理

- 构造的对象需要拆分成多个步骤
- 构造的对象的参比较多
- 定义一个生成器接口，把生成对象的参数构造放到实现类中
- 调用方只需要实现获取生成器接口，就可以完全解耦生成实际对象的差异化

#### 应用场景

- 对象实例化需要多个参数
- 构造对象的操作比较分散

#### 代码示例

```go
// 图形窗口生成器
type IBuilder interface {
    SetWeidth()
    SetHeigth()
    SetBackgd()
    GetWindow()
}

// 默认720 * 1024 白色
type DefaultBuilder struct {
    Weigth int
    Heigth int
    Backgd string
}

func (ptr *DefaultBuilder) SetWeidth() {
    ptr.Weigth = 720
}

func (ptr *DefaultBuilder) SetHeigth() {
    ptr.Heigth = 1024
}

func (ptr *DefaultBuilder) SetBackgd() {
    ptr.Backgd = "white"
}

func (ptr *DefaultBuilder) GetWindow() {
    fmt.Println("Weigth:%d Heigth:%d Backgd:%s", ptr.Weigth, ptr.Heigth, ptr.Backgd)
}

// 全屏 1080 * 1920 黑色
type FullBuilder struct {
    Weigth int
    Heigth int
    Backgd string
}

func (ptr *FullBuilder) SetWeidth() {
    ptr.Weigth = 1080
}

func (ptr *FullBuilder) SetHeigth() {
    ptr.Heigth = 1920
}

func (ptr *FullBuilder) SetBackgd() {
    ptr.Backgd = "black"
}

func (ptr *FullBuilder) GetWindow(){
    fmt.Println("Weigth:%d Heigth:%d Backgd:%s", ptr.Weigth, ptr.Heigth, ptr.Backgd)
}


// 统一的管理类，调用者
type BuildWindow struct {
    Builder IBuilder
}

func (ptr *BuildWindow) SetBuilder(b IBuilder) {
    ptr.Builder = b
}

func (ptr *BuildWindow) GetWindow() {
    ptr.Builder.SetWeidth()
    ptr.Builder.SetHeigth()
    ptr.Builder.SetBackgd()
    ptr.Builder.GetWindow()
}

func main() {
    b := BuildWindow{}
    b.SetBuilder(&DefaultBuilder{})
    b.GetWindow()

    b.SetBuilder(&FullBuilder{})
    b.GetWindow()
}
```

-------- 结构

### 代理模式

#### 设计原理

- 目的对原有接口实例对象的扩展和封装
- 代理和代理对象提供的接口参数一致，这样解耦接口实例和被调用方的逻辑

#### 应用场景

- 对工具类库接口的二次封装，保证同一接口，即可适配不同的工具类库，又可以完全解耦，不修改任何代码逻辑
- 日志库封装，数据库接口封装等

#### 代码示例

```go
// 代理请求实现请求限流

// 统一的服务接口
type IService interface {
    Request(url string) int
}

type AppService struct {

}

func (ptr *AppService) Request(url string) int {
    return 200
}

type ProxyService struct {
    App IService
    ReqStats map[string]int
    MaxLimit int
}

func (ptr *ProxyService) Request(url string) int {
    if Limit(url) {
        return 403
    }

    return ptr.App.Request(url)
}

func (ptr *ProxyService) Limit(url string) bool {
    if nil == ReqStats {
        ReqStats = make(map[string]int)
    }

    stats, ok := ReqStats[url]
    if !ok {
        ReqStats[url] = 1
        return false
    }

    if stats > ptr.MaxLimit {
        return true
    }

    ReqStats[url] = stats + 1

    return false
}

func main() {
    p := &ProxyService{
        App: &AppService{},
        MaxLimit: 2,
    }

    fmt.Println(p.Request("url"))
}
```

### 适配器模式

#### 设计原理

- 当一个接口或者类库定义的标准，满足不了所有业务实现时，可以通过适配层来转换适配

#### 应用场景

- 接口只提供了json数据格式的支持，现在要兼容xml格式数据，而接口实现不支持修改，或者引入修改代价很大

#### 代码示例

```go
// 有两台设备，一台只有usb接口，另一台只有HDMI接口
// 接口只提供了usb，这样封装一个适配层接口

type IAdapter interface {
    InsertUsb()
}

type FlashDisk struct {

}

func (ptr *FlashDisk) InsertUsb() {
    fmt.Println("FlashDisk InsertUsb")
}

type Display struct {

}

func (ptr *Display) InsertHdmi() {
    fmt.Println("Display InsertHdmi")
}

// 适配者
type DisplayAdapter struct {
    D *Display
}

func (ptr *DisplayAdapter) InsertUsb() {
    ptr.D.InsertHdmi()
}

func main() {
    // 调用者
    var a IAdapter

    a = &FlashDisk{}
    a.InsertUsb()

    a = &DisplayAdapter{}
    a.InsertUsb()
}
```

### 桥接模式

#### 设计原理

- 把一个打对象的耦合模块，拆分到不同的层次，独立实现
- 在把耦合的抽象接口，通过参数委派出去

#### 应用场景

- 不同的对象的某个操作有不同实现

#### 代码示例

```go
// 不同平台的打印功能

// 平台抽象定义
type IPlatform interface {
    Print()
    SetPrinter(IPrint)
}

// 行为抽象接口定义
type IPrint interface {
    PrintFile()
}

// 具体的平台
type Windows struct {
    Printer IPrint
}

func (ptr *Windows) Print() {
    ptr.Printer.PrintFile()
}

func (ptr *Windows) SetPrinter(p IPrint) {
    ptr.Printer = p
}

type Mac struct {
    Printer IPrint
}

func (ptr *Mac) Print() {
    ptr.Printer.PrintFile()
}

func (ptr *Mac) SetPrinter(p IPrint) {
    ptr.Printer = p
}

// 具体的打印类
type Hp struct {

}

func (ptr *Hp) PrintFile() {
    fmt.println("Hp printer")
}

type Epson struct {

}

func (ptr *Epson) PrintFile() {
    fmt.println("Epson printer")
}f

func main() {
    hp := &Hp{}
    epson := &Epson{}

    mac := &Mac{}
    mac.SetPrinter(hp)
    mac.Print()

    mac := &Mac{}
    mac.SetPrinter(epson)
    mac.Print()

    win := &Windows{}
    win.SetPrinter(hp)
    win.Print()

    win := &Windows{}
    win.SetPrinter(epson)
    win.Print()
}

```

### 组合模式

#### 设计原理

- 是把多个对象，通过接口组合到一个对象中，对象组合成树形结构
- 在使用上，对单一对象的操作会传递到组合中的所有对象

#### 应用场景

- 多个对象具有相似的功能
- 比如文件和文件夹的搜索功能

#### 代码示例

```go
type IFile interface {
    Search()
}

type File struct {
    Name string
}

func (ptr *File) Search() {
    fmt.Println("Search in file %s", ptr.Name)
}

type Folder struct {
    Files []IFile
    Name string
}

func (ptr *Folder) Search() {
    fmt.Pringln("Search in folder %s", ptr.Name)
    for _, f := range ptr.Files {
        f.Search()
    }
}

func (ptr *Folder) Add(f IFile) {
    ptr.Files = append(ptr.Files, f)
}

func main() {
    // 搜索文件夹
    f1 := &File{
        Name: "f1",
    }

    folder1 := &Folder{
        Name: "folder1",
    }

    folder1.Add(f1)

    f2 := &File{
        Name: "f2",
    }
    f3 := &File{
        Name: "f3",
    }

    folder2 := &Folder{
        Name: "folder2",
    }

    folder2.Add(f2)
    folder2.Add(f3)

    folder3 := &Folder{
        Name: "folder3",
    }

    folder3.Add(folder1)
    folder3.Add(folder2)

    folder3.Search()
}
```

### 装饰模式

#### 设计原理

- 需要新增对象的行为，或者扩展对象现有的行为，而对现有代码无影响
- 通过装饰者，扩展对象的行为。新增的行为可以通过继承的方式增加
- 原始对象通过参数绑定给装饰者

#### 应用场景

- 商品的包装和促销行为
- 不同的促销方式
- 不同的包装价格

#### 代码实例

```go
type IPrice interface {
    GetPrice() int
}

type Shoe struct {
    Price int
}

// 定价
func (ptr *Shoe) GetPrice() int {
    return ptr.Price
}

type OverPrice struct {
    Price IPrice
}

// 涨价了
func (ptr *OverPrice) GetPrice() int {
    return ptr.GetPrice() + 10
}

type BellowPrice struct {
    Price IPrice
}

// 降价了
func (ptr *BellowPrice) GetPrice() int {
    return ptr.GetPrice() - 10
}

func main() {
    var p IPrice
    var s = &Shoe{
        Price: 100,
    }

    s.GetPrice()

    p = &OverPrice{
        Price: s
    }

    p.GetPrice()

    p = &BellowPrice{
        Price: s
    }

    p.GetPrice()
}
```

### 外观模式

#### 设计原理

- 把复杂的类库依赖，放置到同一个接口内，对外提供一个简单易用的一组功能接口
- 外观模式，是把有功能依赖的模块和类库收敛封装起来

#### 应用场景

- 可以按照功能切分出不同的接口，接口实现逻辑复杂步骤比较繁琐

#### 代码实现

```go
// 如点赞功能，首先校验是否登录，是否有权限，点赞以后的通知，是不同模块完成的

// 外观类
type ApprovalFacade struct {
    User *Account
    Aut  *Authority
    Notifier *Notify
}

func (ptr *ApprovalFacade) Approval(user *Account) {
    if !ptr.User.IsLogin() {
        return
    }

    if !ptr.Aut.HasAuthority() {
        return
    }

    ptr.Notifier.Notify("Approval user")
}

type Account struct {

}

func (ptr *Account) IsLogin() bool {
    return true
}

type Authority struct {

}

func (ptr *Authority) HasAuthority() bool {
    return true
}

type Notify struct {

}

func (ptr *Notify) Notify(msg string) {
    fmt.Println(msg)
}

func main() {
    u := &Account{}
    a := &Authority{}
    n := &Notify{}

    f := &ApprovalFacade{
        User: u,
        Aut: a,
        Notifier: n,
    }

    f.Approval()
}

```

### 享元模式

#### 设计原理

- 把多个对象之间相同的属性，封装独立的对象中，这个对象就是享元对象
- 享元对象由享元工厂管理
- 对象对享元的引用由享远工厂管理，比每个对象都维护一个享元对象所占有的内存要少

#### 应用场景

- 管理员，用户的权限等级
- 游戏角色的属性信息

#### 代码实现

```go
//初始化享元工厂
var GlobalPermit PermitFactory{}

// 享元接口
type Permit interface {
    GetPermits() string
}

// 享元对象
type AdminPermit struct {

}

func (ptr *AdminPermit) GetPermits() string {
    return fmt.Sprintf("AdminPermit")
}

// 享元对象
type UserPermit struct {

}

func (ptr *UserPermit) GetPermits() string {
    return fmt.Sprintf("UserPermit")
}

// 享元工厂
type PermitFactory struct {
    Permits map[string]Permit
}

func (ptr *PermitFactory) AddPermit(permitType string, p Permit) {
    if nil == ptr.Permits {
        ptr.Permits = make(map[string]Permit)
    }

    ptr.Permits[permitType] = p
}


type User struct {
    P Permit
    PermitType string
}

func NewUser(permitType string) *User {
    p, ok := GlobalPermit[permitType]
    if !ok {
        return nil
    }

    return &User{
        P: p,
        PermitType: permitType,
    }
}

func (ptr *User) GetPermit() {
    fmt.Println("%s", ptr.P.GetPermits())
}

func main() {
    NewUser("admin")
    NewUser("user1")
    NewUser("user2")
    NewUser("user3")
}

```

--------- 行为

### 策略模式

#### 设计原理

> 需要实现一组算法，而不同的算法可以互相替代

- 提供一类算法接口定义，所有的算法都需要实现这类接口

- 策略可以通过配置初始化，通过工厂生成，或者查表法得到具体的算法策略

- 策略与策略之间没有相互依赖，完全解耦

#### 应用场景

- 设计一个路由限流功能，限流的算法有多种实现，随机，轮询，加权轮询等

#### 代码示例

```go
type ILimitStratege interface {
    Limit()
}

type RandomStratege struct {

}

func (ptr *RandomStratege) Limit() {
    fmt.Println("RandomStratege")
}

type PollStratege struct {

}

func (ptr *PollStratege) Limit() {
    fmt.Println("PollStratege")
}

var StrategeMap = map[string]ILimitStratege{
    "random": RandomStratege{},
    "poll": PollStratege{},
}

func GetStratege(s string) ILimitStratege {
    stratege, ok := StrategeMap[s]
    if !ok {
        return nil
    }

    return stratege
}

func main() {
    s := GetStratege("random")
    s.Limit()
}
```

### 责任链模式

#### 设计原理

> 把请求的发送和接受解藕，多个接收对象，按照条件处理请求对象，可以是顺序处理，可以未知处理

- 处理逻辑接口，包含处理handle接口, 请求上下文需要通过参数方式传入
- 实现链对象, 需要实现下一链的的接口
- 逻辑接口实现对象

#### 应用场景

- web框架过滤器，拦截器

#### 代码示例

```go
// 简单的过滤器实现

// 处理逻辑接口
type IFilter interface {
    Filter(string) bool
}

type FilterChain struct {
    Chain []Filter // 简单的数组存储
    Index int
}

func (ptr *FilterChain) AddChain(f IFilter) {
    ptr.Chain = append(ptr.Chain, f)
}

// 顺序执行
func (ptr *FilterChain) Filter(req string) bool {
    for _, chain := range ptr.Chain {
        if nil != chain {
            if !chain.Filter(req) {
                return false
            }
        }
    }

    return true
}

// 变种实现
func (ptr *FilterChain) Next(req string) {
    ptr.index++
    for ptr.index < len(ptr.Chain) {
        ptr.Chain[ptr.index](req)
        ptr.index++
    }
}

type LowFilter struct {

}

func (ptr *LowFilter) Filter(req string) bool {
    fmt.Println("LowFilter")
    return true
}

type HighFilter struct {

}

func (ptr *HighFilter) Filter(req string) bool {
    fmt.Println("HighFilter")
    return true
}

func main() {
    chain := FilterChain{}
    chain.AddChain(&LowFilter{})
    chain.AddChain(&HighFilter{})
    chain.Handle("req")
}
```

### 状态模式

#### 设计原理

> 状态模式是一种行为模式，对象根据不同的状态执行不同的行为动作，并会产生状态变化。策略模式下，行为对状态改变是未知的

- 状态数据上下文对象, 包含行为接口对象，状态上下文数据
- 行为接口
- 状态行为实现对象，行为逻辑实现以及状态流转

#### 应用场景

> 简单的状态行为选择 if、switch；有限的状态，而且当行为逻辑比较复杂采用状态模式；状态比较多，状态转换复杂，采用查表法

- 插入说明链接

####  代码示例

```go
// 示例场景，工作审批流程
// 提交审批流程->领导审批->人事审批->结束

// 行为接口
type IState interface {
    Approval(*WorkFlow)
    Reject(*WorkFlow)
    GetState() string
}

// 状态上下文对象
type WorkFlow struct {
    State IState
}

func (ptr *WorkFlow) SetState(state IState) {
    ptr.State = state
}

func (ptr *WorkFlow) Approval() {
    if nil != ptr.State {
        ptr.State.Approval()
    }
}

func (ptr *WorkFlow) Reject() {
    if nil != ptr.State {
        ptr.State.Reject()
    }
}

func (ptr *WorkFlow) GetState() {
    if nil != ptr.State {
        ptr.State.GetState()
    }
}

// 状态行为实现
type LeaderState struct {
    StateName string
}

func (ptr *LeaderState) Approval(w *WorkFlow) {
    fmt.Println("Leader Approval")
    w.SetState(&HRState{})
}

func (ptr *LeaderState) Reject(w *WorkFlow) {
    fmt.Println("Leader Reject")
}

func (ptr *LeaderState) GetState() string {
    return ptr.StateName
}

type HRState struct {
    StateName string
}

func (ptr *HRState) Approval(w *WorkFlow) {
    fmt.Println("HR Approval")
}

func (ptr *HRState) Reject(w *WorkFlow) {
    fmt.Println("HR Reject")
    w.SetState(&HRState{})
}

func (ptr *HRState) GetState() string {
    return ptr.StateName
}

func main() {
    w := WorkFlow{}
    //start
    w.SetState(&LeaderState{StateName: "LeaderState"})
    // LeaderState
    w.Approval()

    // Approval
    w.GetState()
    // HRReject
    w.Reject()

    // LeaderState
    w.GetState()

    // LeaderApproval
    w.Approval()

    // HRApproval
    w.GetState()

    // HRApproval
    w.Approval()
    w.GetState()
    // end
}

```

### 访问者模式

#### 设计原理

> 需要对一组对象进行操作访问，而又需要保证对象对封装特性。这个模式的对象关系比较复杂，尽量不做使用

- 操作对象对逻辑通过一组接口和实现类封装起来，对象的信息通过接口参数传递。

- 对象保留实现访问者的接口方法，达到操作解藕的目的

- 访问者必需知道所有的操作对象类

#### 应用场景

- 在系统中生成的单据文件，进行格式化输出

- 如报销单、请假单

- 输出格式支持pdf、doc

#### 代码示例

```go
// 访问者接口
type IVisitor interface {
    PDFVisit(IForm)   // 具体的对象操作逻辑实现接口
    DOCVisit(IForm)   // 具体的对象操作逻辑实现接口
}

// 具体操作实现类
type PDFVisitor struct {

}

func (ptr *PDFVisitor) PDFVisit(form IForm) {
    fmt.Println("PDFVisitor")
}

func (ptr *PDFVisitor) DOCVisit(form IForm) {
    fmt.Println("error visitor")
}

// 具体操作实现类
type DOCVisitor struct {

}

func (ptr *DOCVisitor) PDFVisit(form IForm) {
    fmt.Println("error visitor")
}

func (ptr *DOCVisitor) DOCVisit(form IForm) {
    fmt.Println("DOCVisitor")
}

// 单据基类
type IForm interface {
    Accept(IVisitor) // 提供访问接口，实现操作逻辑解藕
}

// 账单
type StatementForm struct {

}

func (ptr *StatementForm) Accept(visitor IVisitor) {
    visitor.PDFVisit(ptr)
}

// 假期单据
type VacationForm struct {

}

func (ptr *VacationForm) Accept(visitor IVisitor) {
    visitor.DOCVisit(ptr)
}

func main() {
    s := StatementForm{}
    v := VacationForm{}

    p := &PDFVisitor{}
    s.Accept(p)

    d:= &DOCVisitor{}
    v.Accept(d)
}

```

### 命令模式

#### 设计原理

- 属于行为模式，把操作和业务逻辑解耦和分离
- 在操作层和业务层实现一个中间层管理操作动作命令
- 操作层引用命令接口，命令对象则会引用业务对象接口

#### 应用场景

- 饭店下单点餐的单据
- GUI按钮的点击和业务实现，不同的按钮可能对应执行的业务逻辑是一样的

#### 代码示例

```go
// 电视机的遥控按钮，电源开关

// 操作对象,可以是基类
type Button struct {
    cmd Commond
}

func (ptr *Button) Press() {
    ptr.cmd.Execute()
}

// 命令接口
type Commond interface {
    Execute()
}

// 具体的命令描述
type OnCommond struct {
    // 业务接口
    Dev Device
}

func (ptr *OnCommond) Execute() {
    ptr.Dev.On()
}

type OffCommond struct {
    // 业务接口
    Dev Device
}

func (ptr *OnCommond) Execute() {
    ptr.Dev.Off()
}

// 业务接口
type Device interface {
    On()
    Off()
}

// 业务实现类
type TV struct {
    isRuning bool
}

func (ptr *TV) On() {
    ptr.isRuning = true
    fmt.Println("Tv is on")
}

func (ptr *TV) Off() {
    ptr.isRuning = false
    fmt.Println("Tv is off")
}

func main() {
    // 业务实例化
    tv := &TV{}

    // 命令实例化
    OnCommond := &OnCommond{
        Dev: tv,
    }

    OffCommond := &OffCommond{
        Dev: tv,
    }

    // 操作实例化
    on := Button{
        cmd: OnCommond,
    }

    on.Press()

    off := Button{
        cmd: OffCommond,
    }

    off.Press()
}

```

### 迭代器模式

#### 设计原理

- 需要对复杂的集合数据做迭代运算的，需要实现特定的迭代方法
- 把迭代逻辑与调用方和进行解耦，隐藏迭代算法实现
- 集合创建迭代器的接口，迭代器接口，这样不需要修改调用方代码，可以扩展实现不同的迭代方法

#### 应用场景

- 简单的数据集合访问，不需要使用迭代模式
- 复杂的集合如树，图，或者存储的对象比较复杂，而迭代只需要访问特定字段的

#### 代码示例

```go
// 数据对象
type User struct{
    Name string
    Age  int
}

// 定义迭代器接口
type Iterator interface {
    GetNext() *User
    HasNext() bool
}

// 迭代器实现类
type UserIter struct {
    index int
    users []*user
}

func (ptr *UserIter) GetNext() *User {
    if ptr.hasNext() {
        user := ptr.users[ptr.index]
        ptr.index++
        return user
    }
    return nil
}

func (ptr *UserIter) HasNext() bool {
    if ptr.index < len(ptr.users) {
        return true
    }
    return false
}

// 创建迭代器接口
type Collection interface {
    CreateIterator() Iterator
}

// 集合对象
type UserCollection struct {
    Users []*User
}

func (ptr *UserCollection) CreateIterator() Iterator {
    return &UserIter{
        index: 0,
        users: ptr,
    }
}

func main() {
    u1 := &User{
        Name: "Tom",
        Age: 13,
    }

    u2 := &User{
        Name: "jerry",
        Age: 14,
    }

    c := UserCollection{
        Users: []*User{u1, u2},
    }

    iter := c.CreateIterator()

    for iter.HasNext() {
        u := iter.GetNext()
        fmt.Println("User is %v", u)
    }
}

```

### 观察者模式

#### 设计原理

- 是一种行为模式，可理解为发布订阅模式
- 订阅者需要在发布者注册自己感兴趣的事件，比如状态的变化，发布者状态变化时接收通知作出相应的动作
- 订阅者实现一组接口，发布者需要提供注册注销的接口，发布的实现类需要保存订阅者实例对象列表

#### 应用场景

- 订阅报纸
- 消息通知发布

#### 代码示例

```go
// 发布者接口
type IPublish interface {
    Register(ISubscribe)
    Unregister(ISubscribe)
    Publish()
}

// 订阅者接口
type ISubscribe interface {
    Action()
}

type Subscriber struct {

}

func (ptr *Subscriber) Action() {
    fmt.Println("call subscriber action")
}

type Publisher struct {
    Sublist []ISubscribe
}

func (ptr *Publisher) Register(sub ISubscribe) {

}

func (ptr *Publisher) Unregister(sub ISubscribe) {

}

func (ptr *Publisher) Publish() {
    for _,sub := range ptr.Sublist {
        sub.Action()
    }
}

func main() {
    s := &Subscriber{}

    p := &Publisher{}
    p.Register(s)
    p.Publish()
}

```

### 中介者模式

#### 设计原理

- 解耦多个对象之间的耦合关系
- 通过中介者接口，实现不同的耦合逻辑
- 中介者对象通过参数绑定给不同的对象

#### 应用场景

- 火车站进出站调度
- 飞机场启停调度
- 窗口对象之间事件互相通知

#### 代码示例

```go
// 组件接口
type ITask interface {
    Stop()
    Start()
}

type WriteTask struct {
    Mediator IMediator
}

func (ptr *WriteTask) Stop() {
    ptr.Mediator.Notify(ptr)
    fmt.Println("WriteTask stop")
}

func (ptr *WriteTask) Start() {
    fmt.Println("WriteTask start")
}

type ReadTask struct {
    Mediator IMediator
}

func (ptr *ReadTask) Stop() {
    ptr.Mediator.Notify(ptr)
    fmt.Println("ReadTask stop")
}

func (ptr *ReadTask) Start() {
    fmt.Println("ReadTask start")
}

type IMediator interface {
    Notify(ITask)
}

type DispatchMediator struct {
    Tasks []ITask
}

func (ptr *DispatchMediator)Notify(t ITask) {
    if len(ptr.Tasks) > 0 {
        next := ptr.Tasks[0]
        next.Start()
        ptr.Tasks = ptr.Tasks[1:]
    }

    ptr.Tasks = append(ptr.Tasks, t)
}

func main() {
    medator ：= &DispatchMediator{}
    w := &WriteTask{
        Mediator: medator,
    }

    r := &ReadTask{
        Mediator: medator,
    }

    w.Stop()

    r.Stop()
}

```

### 备忘录模式

#### 设计原理

- 在不知道对象内部细节的情况下，可以对对象实现保存和恢复
- 由三个组件构成，原发器、备忘录、负责人
- 对象细节对外部隐藏，负责人记录对象历史数据

#### 应用场景

- 文字编辑器的编辑保存撤销操作

#### 代码实例

```go
// 原发器
type Originator struct {
    state string
}

func (ptr *Originator) GetState() string {
    return ptr.state
}

func (ptr *Originator) SetState(s string) string {
    ptr.state = s
}

func (ptr *Originator) GetMemento() *Memento {
    return &Memento{state: ptr.state}
}

// 备忘录
type Memento struct {
    state string
}

func (ptr *Memento) GetState() string {
    return ptr.state
}

// 负责人
type Caretaker struct {
    Mementos []*Memento
}

func (ptr *Caretaker) GetMemento(index) *Memento {
    if index < 0 || index >= len(ptr.Mementos) {
        return nil
    }

    return ptr.Mementos[index]
}

func (ptr *Caretaker) AddMemento(m *Memento) {
    ptr.Mementos = append(ptr.Mementos, m)
}


func main() {
    c := &Caretaker{}
    o := &Originator{}

    o.SetState("state 0")
    c.AddMemento(o.GetMemento())
    o.SetState("state 1")
    c.AddMemento(o.GetMemento())
    o.SetState(c.GetMemento(0).GetState())
}
```

### 模板模式

#### 设计原理

- 相似对象，有同样的流程，其中只有一部分流程处理有差异
- 把相同的流程或者接口实现，提取到共有的父类，子类覆盖差异化的流程和接口

#### 应用场景

- 从文件导入数据时，文件的格式会不一样
- 到处数据的处理流程是一样的

#### 代码实现

```go
// 定义一组接口，差异化实现
type IOpt interface {
    ParseFile()
    SaveCache()
}

// 模板方法对象
type Opt struct {
    Oprt IOpt
}

func (ptr *Opt) Import() {
    ptr.Oprt.ParseFile()
    ptr.Oprt.SaveCache()
}

type Excel struct {

}

func (ptr *Excel)ParseFile() {
    fmt.Println("Excel ParseFile")
}

func (ptr *Excel)SaveCache() {
    fmt.Println("Excel SaveCache")
}

type Text struct {

}

func (ptr *Text)ParseFile() {
    fmt.Println("Text ParseFile")
}

func (ptr *Text)SaveCache() {
    fmt.Println("Text SaveCache")
}

func Main() {
    e := &Excel{}
    t := &Text{}

    o := &Opt{
        Oprt: e,
    }

    o.Import()

    o := &Opt{
        Oprt: t,
    }

    o.Import()
}

```

### 总结

> 模式不是单独存在的，在一个项目或者模块中，可能需要几种模式并存嵌套使用，但整体意图是把各个耦合的对象，通过模式来进行解耦，达到高内聚低耦合的目的
