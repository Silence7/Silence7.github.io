---
title: 经典知识记录
date: 2020-10-30 10:51:43
tags:
---

> 记录一些常见问题，这些问题无关行业，无关语言，无关框架，以及这些问题的经典解决方案

## 经典解决方案

### 生产者消费者

```go
func Consumer(ch chan<- int) {
    for {
        i := time.Now().Unix()
        ch <- i
        time.Sleep(1 * time.Second)
    }
}

func Producer(ch <-chan int) {
    for {
        select {
        case i <- ch:
        fmt.Println(i)
        default:
        fmt.Println("ch is empty")
        time.Sleep(1 * time.Second)
    }
}

func main() {
    var queue = make(chan int, 10)
    for index := 1; index < 5; index++ {
        go Consumer(queue)
    }

    for index := 1; index < 10; index++ {
        go Producer(queue)
    }
}
```

```C++
#include<iostream>
#include<queue>
#include<stdlib.h>
#include<pthread.h>
#include<unistd.h>

#define NUM 8

class BlockQueue
{
    private:
    std::queue<int> q;
    int cap;
    pthread_mutex_t mutex;
    pthread_cond_t full;
    pthread_cond_t empty;

    private:
    bool IsEmpty()
    {
        return (q.size() == 0 ? true : false);
    }
    bool IsFull()
    {
        return (q.size() == cap ? true : false);
    }

    public:
    BlockQueue(int _cap = NUM):cap(_cap) //构造函数
    {
        pthread_mutex_init(&mutex,NULL);
        pthread_cond_init(&full,NULL);
        pthread_cond_init(&empty,NULL);
    }

    void PushData(const int &data)
    {
        pthread_mutex_lock(&mutex);
        while(IsFull()) //队列满
        {
            pthread_cond_signal(&empty);      // 通知消费者
            std::cout<<"queue full,notify consume data,product stop!!"<<std::endl;
            pthread_cond_wait(&full,&mutex);  // 阻塞生产者
        }
        //队列不满,生产者插入数据，通知消费者队列中已经有数据了
        q.push(data);
        pthread_cond_signal(&empty);
        pthread_mutex_unlock(&mutex);
    }

    void PopData(int &data)
    {
        pthread_mutex_lock(&mutex);
        while(IsEmpty())  //队列为空
        {
            pthread_cond_signal(&full);
            std::cout<<"queue empty,notify product data,consume stop!!"<<std::endl;
            pthread_cond_wait(&empty,&mutex);
        }
        //队列不为空
        data = q.front();
        q.pop();
        pthread_cond_signal(&full);
        pthread_mutex_unlock(&mutex);
    }

    ~BlockQueue()
    {
        pthread_mutex_destroy(&mutex);
        pthread_cond_destroy(&full);
        pthread_cond_destroy(&empty);
    }
};

//消费者
void* consumer(void* arg)
{
    BlockQueue *bqp = (BlockQueue*)arg;
    int data;
    for(;;)
    {
        bqp->PopData(data);
        std::cout<<"Consume data done: "<<data<<std::endl;
    }
}
  
//生产者
void* producter(void* arg)
{
    BlockQueue *bqp = (BlockQueue*)arg;
    srand((unsigned long)time(NULL));
    for(;;)
    {
        int data = rand()%1024;
        bqp->PushData(data);
        std::cout<<"Product data done: "<<data<<std::endl;
        // sleep(1);
    }
}

int main()
{
    BlockQueue bq;
    pthread_t c,p;
  
    pthread_create(&c,NULL,consumer,(void*)&bq);
    pthread_create(&p,NULL,producter,(void*)&bq);

    pthread_join(c,NULL);
    pthread_join(p,NULL);
  
    return 0;
}
```

### 环形队列

> 它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。
   因为有简单高效的原因，甚至在硬件都实现了环形队列.

- 环形队列包含的元素

```C++
class RingQueue
{
    private:
    /*
    如果要实现无锁的环形队列，头索引和尾索引可以定义为 volatile int
    */
    int head;        // 队列头索引
    int tail;        // 队列尾索引
    int maxSize;     // 队列最大长度
    int tag;         // 标志位
    int space[maxSize]; // 元素数组
    public:
    RingQueue(int size = 10)
    {
        maxSize = size
    }
};
```

- 如何判断队列满或者是空

```shell
# 标志位
# 1. 队列空
head == tail && tag == 0
# 2. 队列满
head == tail && tag == 1
# 3. 写队列，尾部移动
tail =  (tail + 1) % maxSize
# 4. 取队列, 头部移动
head = (head + 1) % maxSize

# 预留空间
# 1. 队列空
tail == head
# 2. 队列满
(tail + 1)% maxSize == head
# 3. 写队列，尾部移动
tail =  (tail + 1) % maxSize
# 4. 取队列, 头部移动
head = (head + 1) % maxSize
```

### 定时器

### 负载均衡

### 限流

### 分布式锁

### 分布式事务

## 框架模块

### 配置框架

### 日志框架

### 指标上报

### 链路追踪

### 服务发现
