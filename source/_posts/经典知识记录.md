---
title: 经典知识记录
date: 2020-10-30 10:51:43
tags:
---

> 记录一些常见问题，这些问题无关行业，无关语言，无关框架，以及这些问题的经典解决方案

## 经典解决方案

### 生产者消费者

```go
func Consumer(ch chan<- int) {
    for {
        i := time.Now().Unix()
        ch <- i
        time.Sleep(1 * time.Second)
    }
}

func Producer(ch <-chan int) {
    for {
        select {
        case i <- ch:
        fmt.Println(i)
        default:
        fmt.Println("ch is empty")
        time.Sleep(1 * time.Second)
    }
}

func main() {
    var queue = make(chan int, 10)
    for index := 1; index < 5; index++ {
        go Consumer(queue)
    }

    for index := 1; index < 10; index++ {
        go Producer(queue)
    }
}
```

```C++
#include<iostream>
#include<queue>
#include<stdlib.h>
#include<pthread.h>
#include<unistd.h>

#define NUM 8

class BlockQueue
{
    private:
    std::queue<int> q;
    int cap;
    pthread_mutex_t mutex;
    pthread_cond_t full;
    pthread_cond_t empty;

    private:
    bool IsEmpty()
    {
        return (q.size() == 0 ? true : false);
    }
    bool IsFull()
    {
        return (q.size() == cap ? true : false);
    }

    public:
    BlockQueue(int _cap = NUM):cap(_cap) //构造函数
    {
        pthread_mutex_init(&mutex,NULL);
        pthread_cond_init(&full,NULL);
        pthread_cond_init(&empty,NULL);
    }

    void PushData(const int &data)
    {
        pthread_mutex_lock(&mutex);
        while(IsFull()) //队列满
        {
            pthread_cond_signal(&empty);      // 通知消费者
            std::cout<<"queue full,notify consume data,product stop!!"<<std::endl;
            pthread_cond_wait(&full,&mutex);  // 阻塞生产者
        }
        //队列不满,生产者插入数据，通知消费者队列中已经有数据了
        q.push(data);
        pthread_cond_signal(&empty);
        pthread_mutex_unlock(&mutex);
    }

    void PopData(int &data)
    {
        pthread_mutex_lock(&mutex);
        while(IsEmpty())  //队列为空
        {
            pthread_cond_signal(&full);
            std::cout<<"queue empty,notify product data,consume stop!!"<<std::endl;
            pthread_cond_wait(&empty,&mutex);
        }
        //队列不为空
        data = q.front();
        q.pop();
        pthread_cond_signal(&full);
        pthread_mutex_unlock(&mutex);
    }

    ~BlockQueue()
    {
        pthread_mutex_destroy(&mutex);
        pthread_cond_destroy(&full);
        pthread_cond_destroy(&empty);
    }
};

//消费者
void* consumer(void* arg)
{
    BlockQueue *bqp = (BlockQueue*)arg;
    int data;
    for(;;)
    {
        bqp->PopData(data);
        std::cout<<"Consume data done: "<<data<<std::endl;
    }
}
  
//生产者
void* producter(void* arg)
{
    BlockQueue *bqp = (BlockQueue*)arg;
    srand((unsigned long)time(NULL));
    for(;;)
    {
        int data = rand()%1024;
        bqp->PushData(data);
        std::cout<<"Product data done: "<<data<<std::endl;
        // sleep(1);
    }
}

int main()
{
    BlockQueue bq;
    pthread_t c,p;
  
    pthread_create(&c,NULL,consumer,(void*)&bq);
    pthread_create(&p,NULL,producter,(void*)&bq);

    pthread_join(c,NULL);
    pthread_join(p,NULL);
  
    return 0;
}
```

### 环形队列

> 它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。
   因为有简单高效的原因，甚至在硬件都实现了环形队列.

- 环形队列包含的元素

```C++
class RingQueue
{
    private:
    /*
    如果要实现无锁的环形队列，头索引和尾索引可以定义为 volatile int
    */
    int head;        // 队列头索引
    int tail;        // 队列尾索引
    int maxSize;     // 队列最大长度
    int tag;         // 标志位
    int space[maxSize]; // 元素数组
    public:
    RingQueue(int size = 10)
    {
        maxSize = size
    }
};
```

- 如何判断队列满或者是空

```shell
# 标志位
# 1. 队列空
head == tail && tag == 0
# 2. 队列满
head == tail && tag == 1
# 3. 写队列，尾部移动
tail =  (tail + 1) % maxSize
# 4. 取队列, 头部移动
head = (head + 1) % maxSize

# 预留空间
# 1. 队列空
tail == head
# 2. 队列满
(tail + 1)% maxSize == head
# 3. 写队列，尾部移动
tail =  (tail + 1) % maxSize
# 4. 取队列, 头部移动
head = (head + 1) % maxSize
```

### hash表

> 通过hash函数把key映射到数组的下标

1. hash函数

    ```shell
    # 是一种从任何一种数据中创建小的数字“指纹”的方法
    
    ```

2. hash冲突的解决策略
    1. 开放地址

        ```shell
        # 线性探测，在hash基础上线性增加步长索引
        # 重hash计算步长，重hash的函数必须和初始hash函数不一样，计算的hash值必须不为0
        ```

    2. 链表

        ```shell
        # 在hash冲突以后，通过链表存储相同索引的数据项
        ```

    3. 桶

        ```shell
        # 在hash冲突以后，通过数组存储相同索引的数据项
        # 数组的容量不容易控制，不如链表动态，一般采用链表实现
        ```

### 定时器

### 线程池

### 协程池

### 负载均衡

### 限流

> 常见的限流算法

1. 计数器滑动窗口

    ```go

    ```

2. 漏桶算法，不管进来的流量有多大，都限制为固定速率

    ```go
    // Uber 开源的Limiter

    type Limiter interface {
        // Take should block to make sure that the RPS is met.
        Take() time.Time
    }

    type Clock interface {
        Now() time.Time
        Sleep(time.Duration)
    }

    type state struct {
        last     time.Time
        sleepFor time.Duration
    }

    type limiter struct {
        state unsafe.Pointer
        //lint:ignore U1000 Padding is unused but it is crucial to maintain performance
        // of this rate limiter in case of collocation with other frequently accessed memory.
        padding [56]byte // cache line size - state pointer size = 64 - 8; created to avoid false sharing.

        perRequest time.Duration
        maxSlack   time.Duration
        clock      Clock
    }

    // config configures a limiter.
    type config struct {
        maxSlack time.Duration
        clock    Clock
    }

    // buildConfig combines defaults with options.
    func buildConfig(opts []option) config {
        c := config{
            maxSlack: 10,
            clock:    clock.New(),
        }

        for _, opt := range opts {
            opt(&c)
        }
        return c
    }

    // option configures a Limiter.
    type option func(l *config)

    // New returns a Limiter that will limit to the given RPS.
    func New(rate int, opts ...option) Limiter {
        config := buildConfig(opts)
        l := &limiter{
            perRequest: time.Second / time.Duration(rate),
            maxSlack:   -1 * config.maxSlack * time.Second / time.Duration(rate),
            clock:      config.clock,
        }

        initialState := state{
            last:     time.Time{},
            sleepFor: 0,
        }
        atomic.StorePointer(&l.state, unsafe.Pointer(&initialState))
        return l
    }

    // Take blocks to ensure that the time spent between multiple
    // Take calls is on average time.Second/rate.
    func (t *limiter) Take() time.Time {
        newState := state{}
        taken := false
        for !taken {
            now := t.clock.Now()

            previousStatePointer := atomic.LoadPointer(&t.state)
            oldState := (*state)(previousStatePointer)

            newState = state{}
            newState.last = now

            // If this is our first request, then we allow it.
            if oldState.last.IsZero() {
                taken = atomic.CompareAndSwapPointer(&t.state, previousStatePointer, unsafe.Pointer(&newState))
                continue
            }

            // sleepFor calculates how much time we should sleep based on
            // the perRequest budget and how long the last request took.
            // Since the request may take longer than the budget, this number
            // can get negative, and is summed across requests.
            newState.sleepFor += t.perRequest - now.Sub(oldState.last)
            // We shouldn't allow sleepFor to get too negative, since it would mean that
            // a service that slowed down a lot for a short period of time would get
            // a much higher RPS following that.
            if newState.sleepFor < t.maxSlack {
                newState.sleepFor = t.maxSlack
            }
            if newState.sleepFor > 0 {
                newState.last = newState.last.Add(newState.sleepFor)
            }
            taken = atomic.CompareAndSwapPointer(&t.state, previousStatePointer, unsafe.Pointer(&newState))
        }
        t.clock.Sleep(newState.sleepFor)
        return newState.last
    }

    ```

3. 令牌桶算法

    ```go
    // 可用令牌数=（当前请求时间-上次请求时间）*令牌生成速率 + 上次使用后剩余令牌数
    // TokenBucket 令牌桶
    type TokenBucket struct {
        lastModifiedTime int64  // 上次修改时间
        storedTokens     uint64 // 桶中存储的令牌数
        count            uint64 // 每inter时间内产生count个令牌
        inter            int64  // 产生count个令牌的时间
        maxTokens        uint64 // 最大的令牌数
        sync.RWMutex
    }

    func New(count uint64, inter time.Duration, maxTokens uint64, tokensNow uint64, startTime time.Time) *TokenBucket {
        return &TokenBucket{
            count:            count,
            inter:            inter.Nanoseconds(),
            maxTokens:        maxTokens,
            storedTokens:     tokensNow,
            lastModifiedTime: startTime.UnixNano(),
        }
    }


    func (b *TokenBucket) ReserveWithTime(count uint64, now time.Time) bool {
        if count <= 0 {
            return true
        }

        b.Lock()

        b.sync(now.UnixNano())

        storedTokens := b.storedTokens
        if storedTokens < count {
            b.Unlock()
            return false
        }
        b.storedTokens -= count
        b.Unlock()
        return true
    }

    func (b *TokenBucket) sync(nowNano int64) {
        diff := nowNano - b.lastModifiedTime
        if diff < 0 {
            return
        }
        tokensToPut := uint64(diff/b.inter) * b.count
        if tokensToPut < 1 {
            return
        }

        if sum, e := b.checkedAddUint64(b.storedTokens, tokensToPut); e == nil {
            if sum > b.maxTokens {
                sum = b.maxTokens
            }
            b.storedTokens = sum
        } else {
            return
        }
        b.lastModifiedTime = nowNano
        return
    }

    // sum = a + b，如果溢出，err不为nil。
    func (b *TokenBucket) checkedAddUint64(n1, n2 uint64) (sum uint64, err error) {
        sum = n1 + n2
        if !(((n1 ^ n2) < 0) || ((n1 ^ sum) >= 0)) {
            err = ErrOverflow
        }
        return
    }

    ```

4. 分布式限流

    1. 基于redis的系统限流设计

        ```go
        // https://www.jianshu.com/p/a3d068f2586d 
        ```

    2. 基于QPS的限流

        ```go
        // 为每个应用实列动态的分配QPS
        ```

    3. 第三方发票服务器

        ```go
        // 阿里开源Sentinel
        // 服务器实现规则动态管理，定时加载限流策略，或者是事件触发，应用需要上报限流状态的上报，以及心跳
        // 熔断、降级、类tcp拥塞控制算法
        ```

### 分布式锁

### 分布式事务

## 框架模块

### 配置框架

### 日志框架

### 指标上报

### 链路追踪

### 服务发现
